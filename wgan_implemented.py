# -*- coding: utf-8 -*-
"""WGAN_Implemented.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yUA_fwJkcSf9EK2f-Ta3jUWwncvt3V42
"""

!pip install torch torchvision

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms
import numpy as np
import matplotlib.pyplot as plt

# Define the generator network
class Generator(nn.Module):
    def __init__(self):
        super(Generator, self).__init__()
        self.fc = nn.Linear(100, 784)

    def forward(self, x):
        x = self.fc(x)
        return x.view(-1, 1, 28, 28)

# Define the discriminator network
class Discriminator(nn.Module):
    def __init__(self):
        super(Discriminator, self).__init__()
        self.fc = nn.Sequential(
            nn.Linear(784, 128),
            nn.ReLU(),
            nn.Linear(128, 1),
        )

    def forward(self, x):
        x = x.view(-1, 784)
        x = self.fc(x)
        return x

# Define the secret message
secret_message = input("Enter the message.")

# Convert the message to binary
binary_message = ''.join(format(ord(c), '08b') for c in secret_message)

# Convert the binary message to a numpy array
binary_message_array = np.array(list(binary_message)).astype(int)

# Define a function to embed the secret message into an image
def embed_message(image, message_array):
    flattened_image = image.view(-1)
    num_pixels = flattened_image.size(0)
    num_bits = len(message_array)
    assert num_bits <= num_pixels, "Message too long to embed in image"
    # Convert message_array to a PyTorch tensor and move it to the same device as image
    message_tensor = torch.tensor(message_array, device=image.device, dtype=torch.float32)
    flattened_image[:num_bits] = message_tensor
    return flattened_image.view(image.size())


# Define a function to extract the secret message from an image
def extract_message(image, num_bits):
    flattened_image = image.view(-1)
    return flattened_image[:num_bits]

# Load the MNIST dataset
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize((0.5,), (0.5,))
])
train_loader = torch.utils.data.DataLoader(
    datasets.MNIST('./data', train=True, download=True, transform=transform),
    batch_size=64, shuffle=True)

# Initialize the generator and discriminator
generator = Generator()
discriminator = Discriminator()

# Move models to GPU if available
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
generator.to(device)
discriminator.to(device)

# Define the loss function
loss_function = nn.BCEWithLogitsLoss()

# Define the optimizers
optimizer_G = optim.Adam(generator.parameters(), lr=0.0002, betas=(0.5, 0.999))
optimizer_D = optim.Adam(discriminator.parameters(), lr=0.0002, betas=(0.5, 0.999))

# Training loop
num_epochs = 10
for epoch in range(num_epochs):
    for batch_idx, (real_images, _) in enumerate(train_loader):
        real_images = real_images.to(device)
        batch_size = real_images.size(0)

        # Train discriminator
        discriminator.zero_grad()
        real_logits = discriminator(real_images)
        noise = torch.randn(batch_size, 100, device=device)
        fake_images = generator(noise)
        fake_logits = discriminator(fake_images.detach())
        d_loss = -torch.mean(real_logits) + torch.mean(fake_logits)
        d_loss.backward()
        optimizer_D.step()

        # Clip discriminator weights
        for p in discriminator.parameters():
            p.data.clamp_(-0.01, 0.01)

        # Train generator
        if batch_idx % 5 == 0:
            generator.zero_grad()
            fake_logits = discriminator(fake_images)
            g_loss = -torch.mean(fake_logits)
            g_loss.backward()
            optimizer_G.step()

        if batch_idx % 100 == 0:
            print('Epoch {} [{}/{}] Loss_D: {:.4f} Loss_G: {:.4f}'.format(
                epoch, batch_idx, len(train_loader),
                d_loss.item(), g_loss.item()))

# Generate an image to hide the secret message
noise = torch.randn(1, 100, device=device)
fake_image = generator(noise)
fake_image_with_message = embed_message(fake_image, binary_message_array)

# Extract the secret message from the image
extracted_message = extract_message(fake_image_with_message, len(binary_message_array))

# Convert the extracted binary message to a string
extracted_message_string = ''.join(str(i) for i in extracted_message.cpu().detach().numpy())# Convert the extracted binary message to a string

# Print the extracted message
print("Extracted message:", extracted_message_string)